<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Extending library settings support</title>
<link rel="stylesheet" href="../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.72.0">
<link rel="start" href="../../index.html" title="Chapter&#160;1.&#160;Boost.Log">
<link rel="up" href="../extension.html" title="Extending the library">
<link rel="prev" href="attributes.html" title="Writing your own attributes">
<link rel="next" href="../rationale.html" title="Rationale and FAQ">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="attributes.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../extension.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../rationale.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="log.extension.settings"></a><a href="settings.html" title="Extending library settings support"> Extending library settings support</a>
</h3></div></div></div>
<p>
        If you write your own logging sinks or use your own types in attributes, you may want to add support for these components to the settings parser provided by the library. Without doing this, the library will not be aware of your types and thus will not work properly.
      </p>
<a name="log.extension.settings.adding_support_for_user_defined_types_to_the_formatter_parser"></a><h5>
<a name="id433824"></a>
        <a href="settings.html#log.extension.settings.adding_support_for_user_defined_types_to_the_formatter_parser">Adding support for user-defined types to the formatter parser</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">log</span><span class="special">/</span><span class="identifier">utility</span><span class="special">/</span><span class="identifier">init</span><span class="special">/</span><span class="identifier">formatter_parser</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
        In order to add support for user-defined types to the formatter parser, one has to register a formatter factory. The factory is basically a function object that, when called, will construct a formatter for the particular attribute. Factories are registered with the <code class="computeroutput"><span class="identifier">register_formatter_factory</span></code> function, that besides the factory functor accepts the attribute name that will trigger this factory usage. This way the application can expose the knowledge of the particular attribute to the library. Here's a quick example:
      </p>
<pre class="programlisting"><span class="comment">// Suppose, this class can be used as an attribute value
</span><span class="keyword">struct</span> <span class="identifier">Point</span>
<span class="special">{</span>
    <span class="keyword">double</span> <span class="identifier">m_X</span><span class="special">,</span> <span class="identifier">m_Y</span><span class="special">;</span>

    <span class="comment">// Streaming operator
</span>    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">CharT</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">TraitsT</span> <span class="special">&gt;</span>
    <span class="keyword">friend</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_ostream</span><span class="special">&lt;</span> <span class="identifier">CharT</span><span class="special">,</span> <span class="identifier">TraitsT</span> <span class="special">&gt;&amp;</span> <span class="keyword">operator</span><span class="special">&lt;&lt;</span> <span class="special">(</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_ostream</span><span class="special">&lt;</span> <span class="identifier">CharT</span><span class="special">,</span> <span class="identifier">TraitsT</span> <span class="special">&gt;&amp;</span> <span class="identifier">strm</span><span class="special">,</span> <span class="identifier">Point</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">point</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">strm</span> <span class="special">&lt;&lt;</span> <span class="string">"("</span> <span class="special">&lt;&lt;</span> <span class="identifier">point</span><span class="special">.</span><span class="identifier">m_X</span> <span class="special">&lt;&lt;</span> <span class="string">", "</span> <span class="special">&lt;&lt;</span> <span class="identifier">point</span><span class="special">.</span><span class="identifier">m_Y</span> <span class="special">&lt;&lt;</span> <span class="string">")"</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// This is a helper traits that defines most of the types used by the formatter factories
</span><span class="keyword">typedef</span> <span class="identifier">logging</span><span class="special">::</span><span class="identifier">formatter_types</span><span class="special">&lt;</span> <span class="keyword">char</span> <span class="special">&gt;</span> <span class="identifier">types</span><span class="special">;</span>

<span class="comment">// Formatter factory
</span><span class="identifier">types</span><span class="special">::</span><span class="identifier">formatter_type</span> <span class="identifier">point_formatter_factory</span><span class="special">(</span>
    <span class="identifier">types</span><span class="special">::</span><span class="identifier">string_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">attr_name</span><span class="special">,</span>
    <span class="identifier">types</span><span class="special">::</span><span class="identifier">formatter_factory_args</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">args</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">types</span><span class="special">::</span><span class="identifier">formatter_type</span><span class="special">(</span><span class="identifier">fmt</span><span class="special">::</span><span class="identifier">attr</span><span class="special">&lt;</span> <span class="identifier">Point</span> <span class="special">&gt;(</span><span class="identifier">attr_name</span><span class="special">));</span>
<span class="special">}</span>

<span class="comment">// We can associate the attribute with the name "Coordinates" with the type Point
</span><span class="identifier">logging</span><span class="special">::</span><span class="identifier">register_formatter_factory</span><span class="special">(</span><span class="string">"Coordinates"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">point_formatter_factory</span><span class="special">);</span>
</pre>
<p>
        Now, whenever the formatter parser (the <code class="computeroutput"><span class="identifier">parse_formatter</span></code> function) encounters the "Coordinates" attribute in the format string being parsed, the <code class="computeroutput"><span class="identifier">point_formatter_factory</span></code> will be called to construct the appropriate formatter. This formatter, since it is generated in the user's application, will use the custom streaming operator that is defined for the <code class="computeroutput"><span class="identifier">Point</span></code> class.
      </p>
<p>
        The formatter factory can additionally accept a number of parameters separated with commas that can be specified in the format string. These parameters are broken into (name, value) pairs and passed as the second argument to the factory. For example, we could allow customizing the way our coordinates are presented in log by accepting an additional parameter in the format string like this:
      </p>
<pre class="programlisting">%TimeStamp% %Coordinates(format="{%0.3f; %0.3f}")% %_%</pre>
<p>
        Now in order to support this parameter we should rewrite our factory like this:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">lambda</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lambda</span><span class="special">;</span>

<span class="comment">// This formatter will use custom format string to format the point coordinates
</span><span class="keyword">void</span> <span class="identifier">custom_point_formatter</span><span class="special">(</span>
    <span class="identifier">types</span><span class="special">::</span><span class="identifier">string_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">attr_name</span><span class="special">,</span>
    <span class="identifier">types</span><span class="special">::</span><span class="identifier">ostream_type</span><span class="special">&amp;</span> <span class="identifier">strm</span><span class="special">,</span>
    <span class="identifier">types</span><span class="special">::</span><span class="identifier">record_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rec</span><span class="special">,</span>
    <span class="identifier">types</span><span class="special">::</span><span class="identifier">string_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">format</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">Point</span> <span class="identifier">point</span><span class="special">;</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">logging</span><span class="special">::</span><span class="identifier">extract</span><span class="special">&lt;</span> <span class="identifier">Point</span> <span class="special">&gt;(</span>
        <span class="identifier">attr_name</span><span class="special">,</span>
        <span class="identifier">rec</span><span class="special">.</span><span class="identifier">attribute_values</span><span class="special">(),</span>
        <span class="identifier">lambda</span><span class="special">::</span><span class="identifier">var</span><span class="special">(</span><span class="identifier">point</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">lambda</span><span class="special">::</span><span class="identifier">_1</span><span class="special">))</span>
    <span class="special">{</span>
        <span class="comment">// If the attribute set contains the needed attribute value,
</span>        <span class="comment">// format it into the stream
</span>        <span class="identifier">strm</span> <span class="special">&lt;&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">format</span><span class="special">(</span><span class="identifier">format</span><span class="special">)</span> <span class="special">%</span> <span class="identifier">point</span><span class="special">.</span><span class="identifier">m_X</span> <span class="special">%</span> <span class="identifier">point</span><span class="special">.</span><span class="identifier">m_Y</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">}</span>

<span class="comment">// Formatter factory
</span><span class="identifier">types</span><span class="special">::</span><span class="identifier">formatter_type</span> <span class="identifier">point_formatter_factory</span><span class="special">(</span>
    <span class="identifier">types</span><span class="special">::</span><span class="identifier">string_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">attr_name</span><span class="special">,</span>
    <span class="identifier">types</span><span class="special">::</span><span class="identifier">formatter_factory_args</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">args</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">types</span><span class="special">::</span><span class="identifier">formatter_factory_args</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">args</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="string">"format"</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">it</span> <span class="special">!=</span> <span class="identifier">args</span><span class="special">.</span><span class="identifier">end</span><span class="special">())</span>
    <span class="special">{</span>
        <span class="comment">// The custom format is specified, use the special formatter
</span>        <span class="keyword">return</span> <span class="identifier">types</span><span class="special">::</span><span class="identifier">formatter_type</span><span class="special">(</span><span class="identifier">lambda</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span>
            <span class="special">&amp;</span><span class="identifier">custom_point_formatter</span><span class="special">,</span>
            <span class="identifier">attr_name</span><span class="special">,</span>
            <span class="identifier">lambda</span><span class="special">::</span><span class="identifier">_1</span><span class="special">,</span>
            <span class="identifier">lambda</span><span class="special">::</span><span class="identifier">_2</span><span class="special">,</span>
            <span class="identifier">it</span><span class="special">-&gt;</span><span class="identifier">second</span><span class="special">));</span>
    <span class="special">}</span>
    <span class="keyword">else</span>
    <span class="special">{</span>
        <span class="comment">// No special format specified, do things the traditional way
</span>        <span class="keyword">return</span> <span class="identifier">types</span><span class="special">::</span><span class="identifier">formatter_type</span><span class="special">(</span><span class="identifier">fmt</span><span class="special">::</span><span class="identifier">attr</span><span class="special">&lt;</span> <span class="identifier">Point</span> <span class="special">&gt;(</span><span class="identifier">attr_name</span><span class="special">));</span>
    <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
        However, if you don't need this additional flexibility and all you want is to use your custom streaming operators to format the attribute value, you can omit writing the formatter factory altogether. You can use a simple call like this:
      </p>
<pre class="programlisting"><span class="identifier">logging</span><span class="special">::</span><span class="identifier">register_simple_formatter_factory</span><span class="special">&lt;</span> <span class="identifier">Point</span> <span class="special">&gt;(</span><span class="string">"Coordinates"</span><span class="special">);</span>
</pre>
<p>
        to achieve the same effect that the first version of the <code class="computeroutput"><span class="identifier">point_formatter_factory</span></code> function provides.
      </p>
<a name="log.extension.settings.adding_support_for_user_defined_types_to_the_filter_parser"></a><h5>
<a name="id435572"></a>
        <a href="settings.html#log.extension.settings.adding_support_for_user_defined_types_to_the_filter_parser">Adding support for user-defined types to the filter parser</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">log</span><span class="special">/</span><span class="identifier">utility</span><span class="special">/</span><span class="identifier">init</span><span class="special">/</span><span class="identifier">filter_parser</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
        You can extend filter parser the similar way you can extend the formatter parser - by registering your types into the library. However, since it takes a considerably more complex syntax to describe filters, a filter factory is more than a mere function.
      </p>
<p>
        Filter factories should be objects that derive from the <code class="computeroutput"><span class="identifier">filter_factory</span></code> interface. This base class declares a number of virtual functions that will be called in order to create filters, according to the filter expression. If some functions are not overriden by the factory, the corresponding operations are considered to be not supported by the attribute value. For example, we can define the filter factory for the slightly improved <code class="computeroutput"><span class="identifier">Point</span></code> class defined in the previous section the following way:
      </p>
<pre class="programlisting"><span class="comment">// Suppose, this class can be used as an attribute value
</span><span class="keyword">struct</span> <span class="identifier">Point</span>
<span class="special">{</span>
    <span class="keyword">double</span> <span class="identifier">m_X</span><span class="special">,</span> <span class="identifier">m_Y</span><span class="special">;</span>

    <span class="comment">// Comparison operators
</span>    <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">==</span> <span class="special">(</span><span class="identifier">Point</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">that</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!=</span> <span class="special">(</span><span class="identifier">Point</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">that</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

    <span class="comment">// Streaming operators
</span>    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">CharT</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">TraitsT</span> <span class="special">&gt;</span>
    <span class="keyword">friend</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_ostream</span><span class="special">&lt;</span> <span class="identifier">CharT</span><span class="special">,</span> <span class="identifier">TraitsT</span> <span class="special">&gt;&amp;</span> <span class="keyword">operator</span><span class="special">&lt;&lt;</span> <span class="special">(</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_ostream</span><span class="special">&lt;</span> <span class="identifier">CharT</span><span class="special">,</span> <span class="identifier">TraitsT</span> <span class="special">&gt;&amp;</span> <span class="identifier">strm</span><span class="special">,</span> <span class="identifier">Point</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">point</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">CharT</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">TraitsT</span> <span class="special">&gt;</span>
    <span class="keyword">friend</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_istream</span><span class="special">&lt;</span> <span class="identifier">CharT</span><span class="special">,</span> <span class="identifier">TraitsT</span> <span class="special">&gt;&amp;</span> <span class="keyword">operator</span><span class="special">&gt;&gt;</span> <span class="special">(</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_istream</span><span class="special">&lt;</span> <span class="identifier">CharT</span><span class="special">,</span> <span class="identifier">TraitsT</span> <span class="special">&gt;&amp;</span> <span class="identifier">strm</span><span class="special">,</span> <span class="identifier">Point</span><span class="special">&amp;</span> <span class="identifier">point</span><span class="special">);</span>
<span class="special">};</span>

<span class="keyword">struct</span> <span class="identifier">point_filter_factory</span> <span class="special">:</span>
    <span class="keyword">public</span> <span class="identifier">logging</span><span class="special">::</span><span class="identifier">filter_factory</span><span class="special">&lt;</span> <span class="keyword">char</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="comment">// The callback for filter for the attribute existence test
</span>    <span class="identifier">filter_type</span> <span class="identifier">on_exists_test</span><span class="special">(</span><span class="identifier">string_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">name</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">filter_type</span><span class="special">(</span><span class="identifier">flt</span><span class="special">::</span><span class="identifier">has_attr</span><span class="special">&lt;</span> <span class="identifier">Point</span> <span class="special">&gt;(</span><span class="identifier">name</span><span class="special">));</span>
    <span class="special">}</span>

    <span class="comment">// The callback for equality relation filter
</span>    <span class="identifier">filter_type</span> <span class="identifier">on_equality_relation</span><span class="special">(</span><span class="identifier">string_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">name</span><span class="special">,</span> <span class="identifier">string_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">arg</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">filter_type</span><span class="special">(</span><span class="identifier">flt</span><span class="special">::</span><span class="identifier">attr</span><span class="special">&lt;</span> <span class="identifier">Point</span> <span class="special">&gt;(</span><span class="identifier">name</span><span class="special">)</span> <span class="special">==</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lexical_cast</span><span class="special">&lt;</span> <span class="identifier">Point</span> <span class="special">&gt;(</span><span class="identifier">arg</span><span class="special">));</span>
    <span class="special">}</span>
    <span class="comment">// The callback for inequality relation filter
</span>    <span class="identifier">filter_type</span> <span class="identifier">on_inequality_relation</span><span class="special">(</span><span class="identifier">string_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">name</span><span class="special">,</span> <span class="identifier">string_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">arg</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">filter_type</span><span class="special">(</span><span class="identifier">flt</span><span class="special">::</span><span class="identifier">attr</span><span class="special">&lt;</span> <span class="identifier">Point</span> <span class="special">&gt;(</span><span class="identifier">name</span><span class="special">)</span> <span class="special">!=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lexical_cast</span><span class="special">&lt;</span> <span class="identifier">Point</span> <span class="special">&gt;(</span><span class="identifier">arg</span><span class="special">));</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// The factory can be registered in the following way
</span><span class="identifier">logging</span><span class="special">::</span><span class="identifier">register_filter_factory</span><span class="special">(</span><span class="string">"Coordinates"</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span> <span class="identifier">point_filter_factory</span> <span class="special">&gt;());</span>
</pre>
<p>
        Having done that, whenever the filter parser (the <code class="computeroutput"><span class="identifier">parse_filter</span></code> function) encounters the "Coordinates" attribute mentioned in the filter, it will use the <code class="computeroutput"><span class="identifier">point_filter_factory</span></code> object to construct the appropriate filter. For example, in the case of the following filter
      </p>
<pre class="programlisting">%Coordinates% = "(10, 10)"</pre>
<p>
        the <code class="computeroutput"><span class="identifier">on_equality_relation</span></code> method will be called with <code class="computeroutput"><span class="identifier">name</span></code> argument being "Coordinates" and <code class="computeroutput"><span class="identifier">arg</span></code> being "10, 10".
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          The quotes around the parenthesis are necessary because the filter parser only supports binary relations, while round brackets are already used to group subexpressions of the filter expression. Whenever there is need to pass several parameters to the relation (like in this case - a number of components of the <code class="computeroutput"><span class="identifier">Point</span></code> class) the parameters should be encoded into a quoted string. The string may include C-style escape sequences that will be unfolded upon parsing.
        </p></td></tr>
</table></div>
<p>
        The constructed filter will use the corresponding comparison operators for the <code class="computeroutput"><span class="identifier">Point</span></code> class. Some relation operations, like "&gt;" or "&lt;=", will not be supported for attributes named "Coordinates", and this is just the way we want it, because the <code class="computeroutput"><span class="identifier">Point</span></code> class does not support them either.
      </p>
<p>
        The library allows not only adding support for new types, but also associating new relations with them. For instance, we can create a new relation "is_in_rect" that will yield positive if the coordinates fit into a rectangle denoted with two points. The filter might look like this:
      </p>
<pre class="programlisting">%Coordinates% is_in_rect "(10, 10) - (20, 20)"</pre>
<p>
        To support it one has to define the <code class="computeroutput"><span class="identifier">on_custom_relation</span></code> method in the filter factory:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bll</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lambda</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">Rectangle</span>
<span class="special">{</span>
    <span class="identifier">Point</span> <span class="identifier">m_TopLeft</span><span class="special">,</span> <span class="identifier">m_BottomRight</span><span class="special">;</span>

    <span class="comment">// Streaming operators
</span>    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">CharT</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">TraitsT</span> <span class="special">&gt;</span>
    <span class="keyword">friend</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_ostream</span><span class="special">&lt;</span> <span class="identifier">CharT</span><span class="special">,</span> <span class="identifier">TraitsT</span> <span class="special">&gt;&amp;</span> <span class="keyword">operator</span><span class="special">&lt;&lt;</span> <span class="special">(</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_ostream</span><span class="special">&lt;</span> <span class="identifier">CharT</span><span class="special">,</span> <span class="identifier">TraitsT</span> <span class="special">&gt;&amp;</span> <span class="identifier">strm</span><span class="special">,</span> <span class="identifier">Rectangle</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rect</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">CharT</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">TraitsT</span> <span class="special">&gt;</span>
    <span class="keyword">friend</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_istream</span><span class="special">&lt;</span> <span class="identifier">CharT</span><span class="special">,</span> <span class="identifier">TraitsT</span> <span class="special">&gt;&amp;</span> <span class="keyword">operator</span><span class="special">&gt;&gt;</span> <span class="special">(</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_istream</span><span class="special">&lt;</span> <span class="identifier">CharT</span><span class="special">,</span> <span class="identifier">TraitsT</span> <span class="special">&gt;&amp;</span> <span class="identifier">strm</span><span class="special">,</span> <span class="identifier">Rectangle</span><span class="special">&amp;</span> <span class="identifier">rect</span><span class="special">);</span>
<span class="special">};</span>

<span class="comment">// Our custom filter type
</span><span class="keyword">class</span> <span class="identifier">is_in_rect_filter</span> <span class="special">:</span>
    <span class="keyword">public</span> <span class="identifier">flt</span><span class="special">::</span><span class="identifier">basic_filter</span><span class="special">&lt;</span> <span class="keyword">char</span><span class="special">,</span> <span class="identifier">is_in_rect_filter</span> <span class="special">&gt;</span>
<span class="special">{</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">string_type</span> <span class="identifier">m_Name</span><span class="special">;</span>
    <span class="identifier">Rectangle</span> <span class="identifier">m_Rect</span><span class="special">;</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">is_in_rect_filter</span><span class="special">(</span><span class="identifier">string_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">attr_name</span><span class="special">,</span> <span class="identifier">Rectangle</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rect</span><span class="special">)</span> <span class="special">:</span>
        <span class="identifier">m_Name</span><span class="special">(</span><span class="identifier">attr_name</span><span class="special">),</span>
        <span class="identifier">m_Rect</span><span class="special">(</span><span class="identifier">rect</span><span class="special">)</span>
    <span class="special">{</span>
    <span class="special">}</span>

    <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()</span> <span class="special">(</span><span class="identifier">values_view_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">attrs</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">Point</span> <span class="identifier">point</span><span class="special">;</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">logging</span><span class="special">::</span><span class="identifier">extract</span><span class="special">&lt;</span> <span class="identifier">Point</span> <span class="special">&gt;(</span><span class="identifier">m_Name</span><span class="special">,</span> <span class="identifier">attrs</span><span class="special">,</span> <span class="identifier">bll</span><span class="special">::</span><span class="identifier">var</span><span class="special">(</span><span class="identifier">point</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">bll</span><span class="special">::</span><span class="identifier">_1</span><span class="special">))</span>
        <span class="special">{</span>
            <span class="comment">// Check that the point fits into the rectangle region
</span>            <span class="keyword">return</span> <span class="identifier">point</span><span class="special">.</span><span class="identifier">m_X</span> <span class="special">&gt;=</span> <span class="identifier">m_Rect</span><span class="special">.</span><span class="identifier">m_TopLeft</span><span class="special">.</span><span class="identifier">m_X</span> <span class="special">&amp;&amp;</span> <span class="identifier">point</span><span class="special">.</span><span class="identifier">m_X</span> <span class="special">&lt;=</span> <span class="identifier">m_Rect</span><span class="special">.</span><span class="identifier">m_BottomRight</span><span class="special">.</span><span class="identifier">m_X</span>
                <span class="special">&amp;&amp;</span> <span class="identifier">point</span><span class="special">.</span><span class="identifier">m_Y</span> <span class="special">&gt;=</span> <span class="identifier">m_Rect</span><span class="special">.</span><span class="identifier">m_TopLeft</span><span class="special">.</span><span class="identifier">m_Y</span> <span class="special">&amp;&amp;</span> <span class="identifier">point</span><span class="special">.</span><span class="identifier">m_Y</span> <span class="special">&lt;=</span> <span class="identifier">m_Rect</span><span class="special">.</span><span class="identifier">m_BottomRight</span><span class="special">.</span><span class="identifier">m_Y</span><span class="special">;</span>
        <span class="special">}</span>
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="keyword">false</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">struct</span> <span class="identifier">point_filter_factory</span> <span class="special">:</span>
    <span class="keyword">public</span> <span class="identifier">logging</span><span class="special">::</span><span class="identifier">filter_factory</span><span class="special">&lt;</span> <span class="keyword">char</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="comment">// The callback for custom relation filter
</span>    <span class="identifier">filter_type</span> <span class="identifier">on_custom_relation</span><span class="special">(</span>
        <span class="identifier">string_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">name</span><span class="special">,</span> <span class="identifier">string_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel</span><span class="special">,</span> <span class="identifier">string_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">arg</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">rel</span> <span class="special">==</span> <span class="string">"is_in_rect"</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="comment">// Parse the coordinates of the rectangle region and construct the filter
</span>            <span class="keyword">return</span> <span class="identifier">filter_type</span><span class="special">(</span><span class="identifier">is_in_rect_filter</span><span class="special">(</span><span class="identifier">name</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lexical_cast</span><span class="special">&lt;</span> <span class="identifier">Rectangle</span> <span class="special">&gt;(</span><span class="identifier">arg</span><span class="special">));</span>
        <span class="special">}</span>
        <span class="keyword">else</span>
            <span class="keyword">throw</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span><span class="special">(</span><span class="string">"Relation "</span> <span class="special">+</span> <span class="identifier">rel</span> <span class="special">+</span> <span class="string">" is not supported"</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
        Like with formatters, if all these bells and whistles are not needed, user can register a trivial filter factory with a simple call:
      </p>
<pre class="programlisting"><span class="identifier">logging</span><span class="special">::</span><span class="identifier">register_simple_filter_factory</span><span class="special">&lt;</span> <span class="identifier">Point</span> <span class="special">&gt;(</span><span class="string">"Coordinates"</span><span class="special">);</span>
</pre>
<p>
        In this case, however, the <code class="computeroutput"><span class="identifier">Point</span></code> class has to support all the standard relational operations and have appropriate streaming operators in order to be parsed from a string.
      </p>
<a name="log.extension.settings.adding_support_for_user_defined_sinks"></a><h5>
<a name="id438557"></a>
        <a href="settings.html#log.extension.settings.adding_support_for_user_defined_sinks">Adding support for user-defined sinks</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">log</span><span class="special">/</span><span class="identifier">utility</span><span class="special">/</span><span class="identifier">init</span><span class="special">/</span><span class="identifier">from_stream</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
        The library provides mechanism of extending support for sinks similar to the formatter and filter parsers. In order to be able to mention user-defined sinks in a settings file, the user has to register a sink factory, which is essentially a function object that receives a number of named parameters and returns a pointer to the initialized sink. The factory is registered for a specific destination (see the <a href="../detailed/utilities.html#log.detailed.utilities.init.settings" title="Library initialization from a settings container">settings file description</a>), so whenever a sink with the specified destination is mentioned in the settings file, the factory gets called. For instance, if we have a sink that emits SNMP traps as a result of processing log records, we can register it the following way:
      </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">snmp_backend</span> <span class="special">:</span>
    <span class="keyword">public</span> <span class="identifier">sinks</span><span class="special">::</span><span class="identifier">basic_sink_backend</span><span class="special">&lt;</span> <span class="keyword">char</span><span class="special">,</span> <span class="identifier">sinks</span><span class="special">::</span><span class="identifier">frontend_synchronization_tag</span> <span class="special">&gt;</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// The constructor takes an address of the receiver of the traps
</span>    <span class="keyword">explicit</span> <span class="identifier">snmp_backend</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">trap_receiver</span><span class="special">);</span>

    <span class="comment">// The function consumes the log records that come from the frontend and emits SNMP traps
</span>    <span class="keyword">void</span> <span class="identifier">consume</span><span class="special">(</span><span class="identifier">record_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rec</span><span class="special">);</span>
<span class="special">};</span>

<span class="comment">// Factory function for the SNMP sink
</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span> <span class="identifier">sinks</span><span class="special">::</span><span class="identifier">sink</span><span class="special">&lt;</span> <span class="keyword">char</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">create_snmp_sink</span><span class="special">(</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">params</span><span class="special">)</span>
<span class="special">{</span>
    <span class="comment">// Read parameters for the backend and create it
</span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;::</span><span class="identifier">const_iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">params</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="string">"TrapReceiver"</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">it</span> <span class="special">==</span> <span class="identifier">params</span><span class="special">.</span><span class="identifier">end</span><span class="special">())</span>
        <span class="keyword">throw</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span><span class="special">(</span><span class="string">"TrapReceiver parameter not specified for the SNMP backend"</span><span class="special">);</span>

    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span> <span class="identifier">snmp_backend</span> <span class="special">&gt;</span> <span class="identifier">backend</span> <span class="special">=</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span> <span class="identifier">snmp_backend</span> <span class="special">&gt;(</span><span class="identifier">it</span><span class="special">-&gt;</span><span class="identifier">second</span><span class="special">);</span>

    <span class="comment">// Construct and initialize the final sink
</span>    <span class="keyword">typedef</span> <span class="identifier">sinks</span><span class="special">::</span><span class="identifier">synchronous_sink</span><span class="special">&lt;</span> <span class="identifier">snmp_backend</span> <span class="special">&gt;</span> <span class="identifier">sink_t</span><span class="special">;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span> <span class="identifier">sink_t</span> <span class="special">&gt;</span> <span class="identifier">sink</span> <span class="special">=</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span> <span class="identifier">sink_t</span> <span class="special">&gt;(</span><span class="identifier">backend</span><span class="special">);</span>

    <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">params</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="string">"Filter"</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">it</span> <span class="special">!=</span> <span class="identifier">params</span><span class="special">.</span><span class="identifier">end</span><span class="special">())</span>
        <span class="identifier">sink</span><span class="special">-&gt;</span><span class="identifier">set_filter</span><span class="special">(</span><span class="identifier">logging</span><span class="special">::</span><span class="identifier">parse_filter</span><span class="special">(</span><span class="identifier">it</span><span class="special">-&gt;</span><span class="identifier">second</span><span class="special">));</span>

    <span class="keyword">return</span> <span class="identifier">sink</span><span class="special">;</span>
<span class="special">}</span>

<span class="identifier">logging</span><span class="special">::</span><span class="identifier">register_sink_factory</span><span class="special">(</span><span class="string">"SNMP"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">create_snmp_sink</span><span class="special">);</span>
</pre>
<p>
        Now the SNMP sink can be constructed with the following settings:
      </p>
<pre class="programlisting">[Sink:MySNMPSink]

Destination=SNMP
Filter="%Severity% &gt; 3"
</pre>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../../../../doc/html/images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
          Although users are free to name parameters of their sinks the way they like, a good choice would be to follow the naming policy established by the library. That is, it should be obvious that the parameter "Filter" means the same for both the library-provided "TextFile" sink and your custom "SNMP" sink backend.
        </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          As the "Destination" parameter is used to determine the sink factory, this parameter is reserved and cannot be used by sink factories for their own purposes.
        </p></td></tr>
</table></div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2007 , 2008, 2009, 2010 Andrey Semashev<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>).
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="attributes.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../extension.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../rationale.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
